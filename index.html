<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WebXR 원추 이중 헬릭스 (7점→시드)</title>
<style>
  :root{color-scheme:dark}
  html,body{margin:0;height:100%;background:#000;font-family:system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,Malgun Gothic,sans-serif}
  #ui{position:fixed;left:12px;top:12px;z-index:20;background:rgba(0,0,0,.72);color:#fff;padding:12px 14px;border-radius:14px;min-width:360px;backdrop-filter:blur(6px);box-shadow:0 8px 24px rgba(0,0,0,.35)}
  #ui h3{margin:0 0 8px;font-size:16px}
  #ui label{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:6px 0}
  #ui input[type="number"],#ui input[type="range"]{width:170px}
  #row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
  #status{opacity:.95;font-size:12px}
  #pointsCanvas{position:fixed;right:12px;top:12px;width:min(36vw,420px);aspect-ratio:1/1;background:#111;border:1px solid #333;border-radius:12px}
  #hint{position:fixed;right:16px;top:14px;color:#bbb;font-size:12px}
  button{cursor:pointer;border-radius:10px;padding:8px 12px;border:1px solid #333;background:#181818;color:#fff}
  button:disabled{opacity:.5;cursor:not-allowed}
</style>
</head>
<body>
<div id="ui">
  <h3>WebXR 원추 이중 헬릭스</h3>
  <div id="row">
    <button id="startBtn">시작</button>
    <button id="stopBtn">중지</button>
    <button id="enterVR">VR 시작</button>
  </div>
  <label>라인 총 수(생성 후보) <input id="pool" type="number" min="200" max="4000" step="50" value="1200"></label>
  <label>선택 수(A+B) <input id="pick" type="number" min="100" max="1200" step="10" value="200"></label>
  <label>기본 반경(px) <input id="rangeR" type="range" min="60" max="900" step="5" value="300"></label>
  <label>높이(m) <input id="height" type="range" min="2" max="8" step="0.1" value="4.0"></label>
  <label>회전 속도 <input id="spin" type="range" min="0.0" max="8" step="0.1" value="2.4"></label>
  <label>꼬임 주기 <input id="twist" type="range" min="80" max="1600" step="10" value="520"></label>
  <label>기울기 오프셋(m) <input id="tilt" type="range" min="0.00" max="0.60" step="0.01" value="0.22"></label>
  <label>색상 부드러움 <input id="smoothAlpha" type="range" min="0.01" max="0.5" step="0.01" value="0.14"></label>
  <label>배경 회색(0~1) <input id="bgGray" type="range" min="0" max="1" step="0.01" value="0"></label>
  <label>그라데이션 세기 <input id="bgGrad" type="range" min="0" max="3" step="0.01" value="1.0"></label>
  <label>아펙스 거리(1~2m) <input id="apexDist" type="range" min="1" max="2" step="0.01" value="1.6"></label>
  <div id="status">상태: 오른쪽 패널에서 점 7개를 찍어 시드를 만드세요.</div>
</div>
<canvas id="pointsCanvas"></canvas>
<div id="hint">점 패널 — 클릭/터치(7개). VR에선 정면 보드 찍기</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { VRButton } from "https://unpkg.com/three@0.160.0/examples/jsm/webxr/VRButton.js";

// ===== UI refs =====
const ui={
  start:document.getElementById('startBtn'),
  stop:document.getElementById('stopBtn'),
  enterVR:document.getElementById('enterVR'),
  pool:document.getElementById('pool'),
  pick:document.getElementById('pick'),
  rangeR:document.getElementById('rangeR'),
  height:document.getElementById('height'),
  spin:document.getElementById('spin'),
  twist:document.getElementById('twist'),
  tilt:document.getElementById('tilt'),
  smoothAlpha:document.getElementById('smoothAlpha'),
  status:document.getElementById('status'),
};

// ===== Points panel (7개) =====
const pCanvas=document.getElementById('pointsCanvas');
const pCtx=pCanvas.getContext('2d');
let P_W=360,P_H=360; let points=[]; // {x,y}
function resizePointCanvas(){
  const rect=pCanvas.getBoundingClientRect();
  const dpr=Math.max(1,window.devicePixelRatio||1);
  pCanvas.width=Math.floor(rect.width*dpr);
  pCanvas.height=Math.floor(rect.height*dpr);
  P_W=pCanvas.width; P_H=pCanvas.height; drawPoints();
}
function drawPoints(){
  pCtx.fillStyle='#0d0d0d'; pCtx.fillRect(0,0,P_W,P_H);
  // grid
  pCtx.strokeStyle='#1b1b1b'; pCtx.lineWidth=1;
  for(let i=0;i<=10;i++){ const x=(P_W/10)*i,y=(P_H/10)*i; pCtx.beginPath(); pCtx.moveTo(x,0); pCtx.lineTo(x,P_H); pCtx.stroke(); pCtx.beginPath(); pCtx.moveTo(0,y); pCtx.lineTo(P_W,y); pCtx.stroke(); }
  // polyline
  if(points.length){
    pCtx.fillStyle='#ffee66';
    for(const p of points){ pCtx.beginPath(); pCtx.arc(p.x,p.y,8,0,Math.PI*2); pCtx.fill(); }
    pCtx.strokeStyle='#ffeb3b'; pCtx.lineWidth=3; pCtx.beginPath(); pCtx.moveTo(points[0].x,points[0].y);
    for(let i=1;i<points.length;i++) pCtx.lineTo(points[i].x,points[i].y);
    if(points.length===7) pCtx.lineTo(points[0].x,points[0].y);
    pCtx.stroke();
  }
}
function addPointXY(clientX,clientY){
  if(points.length>=7) return;
  const rect=pCanvas.getBoundingClientRect(); const dpr=Math.max(1,window.devicePixelRatio||1);
  const x=(clientX-rect.left)*dpr; const y=(clientY-rect.top)*dpr;
  if(x<0||y<0||x>rect.width*dpr||y>rect.height*dpr) return;
  points.push({x,y}); drawPoints(); ui.status.textContent=`상태: 점 ${points.length}/7`;
}
function handlePointer(e){ if(e.type==='pointerdown'||e.type==='mousedown'){ addPointXY(e.clientX,e.clientY); } else if(e.type==='touchstart'){ const t=e.changedTouches&&e.changedTouches[0]; if(t) addPointXY(t.clientX,t.clientY); } }

pCanvas.addEventListener('pointerdown',handlePointer,{passive:true});
pCanvas.addEventListener('mousedown',handlePointer,{passive:true});
pCanvas.addEventListener('touchstart',e=>{e.preventDefault();handlePointer(e)},{passive:false});
pCanvas.addEventListener('dblclick',()=>{points=[];drawPoints();ui.status.textContent='상태: 점 0/7';});
window.addEventListener('resize',resizePointCanvas); resizePointCanvas();

// ===== Seed RNG =====
function computeSeed(){ let s=0; points.forEach((p,i)=>{ s^=((p.x+p.y)|0)<<(i%31); }); return (s>>>0)||0x9e3779b9; }
function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^(t>>>15),t|1); t^=t+Math.imul(t^(t>>>7),t|61); return ((t^(t>>>14))>>>0)/4294967296; }; }
let rng=mulberry32(0x1234abcd);

// ===== Three.js / WebXR =====
const scene=new THREE.Scene(); scene.background=new THREE.Color(0x000000);
const camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,0.01,100); camera.position.set(0,1.6,2.2);
const renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth,window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2)); renderer.xr.enabled=true; document.body.appendChild(renderer.domElement);

// floor
// 바닥은 내부 시야를 방해할 수 있어 비활성화
// const floor=new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.MeshBasicMaterial({color:0x080808,transparent:true,opacity:0.9,side:THREE.DoubleSide})); floor.rotation.x=-Math.PI/2; floor.position.y=0; scene.add(floor);
const light=new THREE.AmbientLight(0xffffff,0.9); scene.add(light);

// VR button
ui.enterVR.addEventListener('click',()=>{ const btn=VRButton.createButton(renderer); btn.style.display='none'; document.body.appendChild(btn); btn.click(); });

// ===== 원추 이중 헬릭스 상태 =====
const palette=[0x32cd32,0x00ff7f,0x9acd32,0xffff00,0xffd700,0xf0e68c,0x9370db,0x8a2be2,0xba55d3,0x1e90ff,0x87cefa,0xff6347,0xff4500].map(v=>new THREE.Color(v));

const state={
  running:false,
  pool:1200,
  pick:200,
  height:4.0,
  segY:220,
  objsA:[], // 헬릭스 A 라인들
  objsB:[], // 헬릭스 B 라인들
  colNowA:[], colNowB:[], colTgtA:[], colTgtB:[],
  rays:[],   // 중심에서 뻗는 방사 원추 라인들
};

// 카메라 정면에 배치할 루트 그룹 (원추 중심이 정면에 오도록)
const conesRoot=new THREE.Group();
scene.add(conesRoot);

function initHelices(){
  // cleanup
  for(const o of state.objsA) scene.remove(o); for(const o of state.objsB) scene.remove(o);
  state.objsA.length=0; state.objsB.length=0; state.colNowA.length=0; state.colNowB.length=0; state.colTgtA.length=0; state.colTgtB.length=0;

  const seg=state.segY; const geomT=new THREE.BufferGeometry(); geomT.setAttribute('position',new THREE.BufferAttribute(new Float32Array(seg*3),3));

  // 씨드 기반 선택: 풀에서 무작위로 pick/2 개씩 A,B에 할당
  const poolN=Math.max(200,Math.min(4000,Number(ui.pool.value)||1200));
  const pickN=Math.max(100,Math.min(poolN,Number(ui.pick.value)||200));
  const pickHalf=Math.floor(pickN/2);

  // 재시드
  const sd=computeSeed(); rng=mulberry32(sd); ui.status.textContent=`상태: 시드 0x${sd.toString(16)} / 선택 ${pickN}개 (A ${pickHalf}, B ${pickN-pickHalf})`;

  // 무작위 인덱스 생성 (중복 최소화)
  const chosen=new Set();
  while(chosen.size<pickN){ const idx=Math.floor(rng()*poolN); chosen.add(idx); }
  const all=[...chosen];

  // 각 라인의 위상/색 초기값도 시드에서 파생
  function newLine(){ const g=geomT.clone(); const m=new THREE.LineBasicMaterial({vertexColors:false}); const l=new THREE.Line(g,m); conesRoot.add(l); return l; }

  for(let i=0;i<pickHalf;i++){
    const line=newLine(); state.objsA.push(line);
    const c=palette[Math.floor(rng()*palette.length)].clone(); const t=palette[Math.floor(rng()*palette.length)].clone();
    state.colNowA.push(c); state.colTgtA.push(t);
  }
  for(let i=pickHalf;i<pickN;i++){
    const line=newLine(); state.objsB.push(line);
    const c=palette[Math.floor(rng()*palette.length)].clone(); const t=palette[Math.floor(rng()*palette.length)].clone();
    state.colNowB.push(c); state.colTgtB.push(t);
  }
  // 중심에서 시작하는 방사 원추 라인 생성 (두 번째 원추)
  // pick 수에 비례해 적정 개수 생성
  for(let i=0;i<Math.max(60, Math.floor(pickN*0.4)); i++){
    const g=geomT.clone();
    const mat=new THREE.LineBasicMaterial({color:palette[Math.floor(rng()*palette.length)]});
    const line=new THREE.Line(g,mat);
    conesRoot.add(line);
    state.rays.push(line);
  }
}

function retargetColors(){
  // 일부 라인의 목표색을 바꿈(랜덤)
  const alpha=Number(ui.smoothAlpha.value)||0.14; // 사용하되 여기선 보간 속도
  const changeCount=Math.max(1,Math.floor((state.objsA.length+state.objsB.length)*0.3));
  for(let k=0;k<changeCount;k++){
    const list=Math.random()<0.5?state.colTgtA:state.colTgtB; const i=Math.floor(Math.random()*list.length);
    list[i]=palette[Math.floor(Math.random()*palette.length)].clone();
  }
}

// 주기적으로 색 타겟 갱신
let colorTimer=null;
function startColorTimer(){ if(colorTimer) clearInterval(colorTimer); colorTimer=setInterval(retargetColors, 2200); }
function stopColorTimer(){ if(colorTimer){clearInterval(colorTimer); colorTimer=null;} }

// 애니메이션 루프
const clock=new THREE.Clock();
function animate(){ renderer.setAnimationLoop(render); }

function render(){
  const t=clock.getElapsedTime();
  if(state.running){ updateHelixLines(t); }
  // 카메라 정면으로 루트 그룹 위치/방향 동기화
  syncConesRootToCamera();
  renderer.render(scene,camera);
}

function updateHelixLines(t){
  const seg=state.segY; const stepY=Number(ui.height.value||4.0)/ (seg-1);
  const baseR=(Number(ui.rangeR.value)||300)/300 * 0.9; // px → m 비례 보정
  const spin=Number(ui.spin.value)||2.4; const twist=Number(ui.twist.value)||520; const tilt=Number(ui.tilt.value)||0.22; const smooth=Number(ui.smoothAlpha.value)||0.14;

  // 카메라 정면 방향으로 원추가 뻗도록 수정
  const camForward = new THREE.Vector3();
  camera.getWorldDirection(camForward);
  camForward.normalize();
  function updateGroup(list, colNow, colTgt, phaseSign){
    for(let i=0;i<list.length;i++){
      const line=list[i];
      // 색 보간
      colNow[i].lerp(colTgt[i], smooth); line.material.color.copy(colNow[i]);
      const pos=line.geometry.attributes.position.array; let p=0;
      const phase0 = i * (Math.PI*2/24) + i*0.0013; // 라인별 고유 위상
      for(let s=0;s<seg;s++){
        // Apex(0) -> 카메라 정면 방향으로 진행
        const y = s*stepY;
        const hNorm = y / (Number(ui.height.value||4.0));
        const radius = baseR * Math.pow(hNorm, 0.85);
        const phase = (y / (twist/1000)) * Math.PI*2 + t*spin*phaseSign + phase0;
        // 원추의 진행 방향을 카메라 정면 방향으로 적용
        const dir = camForward.clone().multiplyScalar(y);
        const x = Math.sin(phase) * radius + (phaseSign>0? +tilt : -tilt);
        const z = Math.cos(phase) * radius;
        pos[p++]=dir.x + x;
        pos[p++]=dir.y + x; // x값을 y에도 더해 약간의 기울기 효과
        pos[p++]=dir.z + z;
      }
      line.geometry.attributes.position.needsUpdate=true;
    }
  }

  // A: +spin 방향, +x 기울기 / B: -spin 방향, -x 기울기
  updateGroup(state.objsA, state.colNowA, state.colTgtA, +1);
  updateGroup(state.objsB, state.colNowB, state.colTgtB, -1);

  // 중심에서 뻗는 방사 원추 업데이트
  updateRays(t, baseR, stepY);
}

// 카메라 정면으로 그룹을 이동/정렬: 카메라가 원추 내부에서 끝(아펙스)을 바라보도록
function syncConesRootToCamera(){
  const camPos=new THREE.Vector3();
  const forward=new THREE.Vector3();
  camera.getWorldPosition(camPos);
  camera.getWorldDirection(forward); // 카메라가 바라보는 방향 (정규화됨)
  // 아펙스는 카메라가 바라보는 앞으로 슬라이더 거리
  const apexSlider=document.getElementById('apexDist');
  const distance = Math.max(1.0, Math.min(2.0, parseFloat(apexSlider?.value||'1.6')));
  conesRoot.position.copy(camPos).add(forward.multiplyScalar(distance));
  // 원추 로컬 Y축(0,1,0)을 카메라 정면 방향에 정렬 (아펙스가 +Y)
  const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), camera.getWorldDirection(new THREE.Vector3()).normalize());
  conesRoot.quaternion.copy(q);
}

// 방사 원추 라인들 업데이트: 각 라인은 중심에서 시작해 위로 퍼지도록
function updateRays(t, baseR, stepY){
  const seg=state.segY;
  const H=Number(ui.height.value||4.0);
  const spin=Number(ui.spin.value)||2.4;
  // 카메라 정면 방향으로 원추 라인 뻗기
  const camForward = new THREE.Vector3();
  camera.getWorldDirection(camForward);
  camForward.normalize();
  for(let i=0;i<state.rays.length;i++){
    const line=state.rays[i];
    const pos=line.geometry.attributes.position.array; let p=0;
    const theta0 = (i/state.rays.length)*Math.PI*2;
    const theta = theta0 + t*0.15*spin;
    for(let s=0;s<seg;s++){
      const yNorm = s/(seg-1);
      const y = yNorm * (H/2);
      const radius = baseR * Math.pow(yNorm, 1.0);
      const dir = camForward.clone().multiplyScalar(y);
      const x = Math.cos(theta)*radius;
      const z = Math.sin(theta)*radius;
      pos[p++]=dir.x + x;
      pos[p++]=dir.y + x;
      pos[p++]=dir.z + z;
    }
    line.geometry.attributes.position.needsUpdate=true;
  }
}

// 버튼 핸들러
ui.start.addEventListener('click',()=>{
  if(points.length!==7){ alert('점 7개를 먼저 찍어주세요.'); return; }
  initHelices(); state.running=true; startColorTimer();
});
ui.stop.addEventListener('click',()=>{ state.running=false; stopColorTimer(); ui.status.textContent='상태: 중지됨. 더블클릭으로 점 초기화 가능'; });

// 리사이즈
window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });

animate();

// ===== 배경 그라데이션 컨트롤 =====
const bgGray=document.getElementById('bgGray');
const bgGrad=document.getElementById('bgGrad');
function applyBackground(){
  const g=parseFloat(bgGray.value||'0');
  // 기본 배경 회색
  scene.background = new THREE.Color().setScalar(Math.max(0,Math.min(1,g)));
  // 그라데이션 세기는 라인 머티리얼 투명도/감마를 미세 조절 (간단 버전)
  const grad=parseFloat(bgGrad.value||'1');
  const exposure = THREE.MathUtils.clamp(1.0/Math.max(0.2,grad), 0.2, 5.0);
  renderer.toneMappingExposure = exposure;
}
bgGray.addEventListener('input',applyBackground);
bgGrad.addEventListener('input',applyBackground);
applyBackground();
</script>
</body>
</html>
