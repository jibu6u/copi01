<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>WebXR 꼬깔콘 모자 내부 이중 헬릭스 (오큘러스용)</title>
<style>
  html,body{margin:0;height:100%;background:#222;}
</style>
</head>
<body>
<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { VRButton } from "https://unpkg.com/three@0.160.0/examples/jsm/webxr/VRButton.js";
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);
const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
camera.position.set(0, 0.2, 0.0); // 원추 내부 바닥(넓은 부분)
camera.lookAt(0, 4.0, 0); // 꼭지점(막힌 부분)을 바라봄
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
const light = new THREE.AmbientLight(0xffffff, 0.9);
scene.add(light);
document.body.appendChild(VRButton.createButton(renderer));
// 다양한 색상 팔레트
const palette = [0xffeb3b,0x44aaff,0xff6347,0x32cd32,0x00ff7f,0x9acd32,0xffff00,0xffd700,0xf0e68c,0x9370db,0x8a2be2,0xba55d3,0x1e90ff,0x87cefa,0xff4500];
// 꼬깔콘 꼭지점(머리 위쪽) 막기 위한 원추 면 추가
const coneHeight = 4.0;
const coneRadius = 1.8;
const coneGeom = new THREE.ConeGeometry(coneRadius, coneHeight, 120, 1, false); // 막힌 원추
const coneMat = new THREE.MeshBasicMaterial({color:0x222222, side:THREE.BackSide, transparent:true, opacity:0.98});
const coneMesh = new THREE.Mesh(coneGeom, coneMat);
coneMesh.position.set(0, coneHeight/2, 0);
scene.add(coneMesh);
// 이중 헬릭스 라인 생성 (꼬깔 중심으로 몰림)
const lineCount = 200;
const seg = 220;
for(let k=0;k<lineCount;k++){
  // 시계방향(꼬깔 중심으로 올라감)
  {
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(seg*3);
    const phase0 = k * (Math.PI*2/lineCount);
    for(let i=0;i<seg;i++){
      const y = i * (coneHeight/(seg-1)); // 바닥에서 꼭지점으로
      const hNorm = 1.0 - y/coneHeight; // 꼭지점으로 몰림
      const radius = coneRadius * hNorm;
      const phase = (y/1.2)*Math.PI*2 + phase0;
      pos[i*3+0] = Math.sin(phase) * radius;
      pos[i*3+1] = y;
      pos[i*3+2] = Math.cos(phase) * radius;
    }
    geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const mat = new THREE.LineBasicMaterial({color:palette[k%palette.length]});
    const line = new THREE.Line(geom, mat);
    scene.add(line);
  }
  // 반시계방향(꼬깔 중심으로 올라감)
  {
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(seg*3);
    const phase0 = k * (Math.PI*2/lineCount);
    for(let i=0;i<seg;i++){
      const y = i * (coneHeight/(seg-1));
      const hNorm = 1.0 - y/coneHeight;
      const radius = coneRadius * hNorm;
      const phase = (y/1.2)*Math.PI*2 + phase0;
      pos[i*3+0] = Math.sin(-phase) * radius;
      pos[i*3+1] = y;
      pos[i*3+2] = Math.cos(-phase) * radius;
    }
    geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const mat = new THREE.LineBasicMaterial({color:palette[(k+7)%palette.length]});
    const line = new THREE.Line(geom, mat);
    scene.add(line);
  }
}
function animate(){
  renderer.setAnimationLoop(()=>{
    renderer.render(scene, camera);
  });
}
animate();
</script>
</body>
</html>
